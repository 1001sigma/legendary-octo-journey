<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cosmic Hand Particles | WebGL Interactive</title>
    
    <script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script>
    <script>try{new VConsole();}catch(e){}</script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --glass-bg: rgba(20, 20, 25, 0.4);
            --glass-border: rgba(255, 255, 255, 0.1);
            --accent: #00f0ff;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
            color: white;
            user-select: none;
        }
        #canvas-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1;
        }
        #input-video {
            position: absolute;
            top: 0; left: 0;
            opacity: 0;
            pointer-events: none;
            z-index: -1;
            transform: scaleX(-1);
        }
        
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            padding: 24px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 16px;
            pointer-events: auto;
            max-width: 300px;
        }

        .hud-top-right {
            position: absolute;
            top: 24px; right: 24px;
            display: flex;
            gap: 12px;
        }

        .icon-btn {
            width: 44px; height: 44px;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        .active-mode {
            font-size: 16px;
            font-weight: 600;
            color: var(--accent);
            text-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
        }

        .loading-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s;
        }
        .loader {
            width: 48px; height: 48px;
            border: 3px solid #FFF;
            border-radius: 50%;
            display: inline-block;
            position: relative;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        .loader::after {
            content: '';  
            box-sizing: border-box;
            position: absolute;
            left: 50%; top: 50%;
            transform: translate(-50%, -50%);
            width: 40px; height: 40px;
            border-radius: 50%;
            border: 3px solid transparent;
            border-bottom-color: var(--accent);
        }
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://esm.sh/three@0.160.0",
            "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
            "gsap": "https://esm.sh/gsap@3.12.5"
        }
    }
    </script>
</head>
<body>

    <div class="loading-overlay" id="loader">
        <div class="loader"></div>
        <p id="loading-text" style="margin-top: 20px; font-size: 14px; opacity: 0.7;">INITIALIZING CORE...</p>
    </div>

    <video id="input-video" playsinline muted autoplay></video>
    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="hud-panel">
            <div style="font-size: 12px; color: rgba(255,255,255,0.6);">SYSTEM STATUS</div>
            <div class="active-mode" id="system-status">IDLE</div>
            <div style="margin-top: 10px; font-size: 12px; color: #888;">
                FPS: <span id="fps-counter">0</span> | Particles: 12,000
            </div>
            <div style="margin-top: 8px; height: 2px; background: rgba(255,255,255,0.1); width: 100%;">
                <div id="gesture-bar" style="height: 100%; width: 0%; background: var(--accent); transition: width 0.1s;"></div>
            </div>
        </div>

        <div class="hud-top-right">
            <button class="icon-btn" id="fs-btn">
                <svg viewBox="0 0 24 24" style="width:20px;height:20px;fill:white;"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
            </button>
        </div>

        <div class="hud-panel" style="align-self: flex-end; text-align: right;">
            <div style="font-size: 12px; color: rgba(255,255,255,0.6);">INTERACTION GUIDE</div>
            <div style="font-size: 13px; line-height: 1.5;">
                ‚úä <b>FIST:</b> Black Hole<br>
                üñê <b>OPEN:</b> Supernova<br>
                ‚Üî <b>HANDS:</b> Scale
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'gsap';

        // --- Ê†∏ÂøÉÈÖçÁΩÆ ---
        const CONFIG = {
            particleCount: 12000,
            particleSize: 2.0,
            colors: {
                idle: new THREE.Color('#00f0ff'),
                blackHoleCore: new THREE.Color('#220044'),
                blackHoleRim: new THREE.Color('#001133'),
                novaCore: new THREE.Color('#ffaa00'),
                novaRim: new THREE.Color('#ff0033')
            },
            physics: {
                G: 300,
                returnSpeed: 0.03
            }
        };

        let scene, camera, renderer, composer;
        let particles, geometry, material;
        let positions, velocities, initialPositions, colors; 
        let handLandmarks = [];
        let gestureState = 'IDLE'; 
        let gestureTimer = 0;
        let bloomPass;
        
        const interaction = {
            targetScale: 1.0,
            currentScale: 1.0,
            handPos: new THREE.Vector3(0, 0, 0),
            handRotation: 0,
            smoothHandPos: new THREE.Vector3(0, 0, 0),
            smoothHandRot: 0
        };

        const vertexShader = `
            uniform float uTime;
            uniform float uScale;
            attribute vec3 color;
            attribute float sizeOffset;
            varying vec3 vColor;
            
            void main() {
                vColor = color;
                vec3 pos = position;
                float noise = sin(pos.x * 2.0 + uTime) * cos(pos.y * 1.5 + uTime) * 0.1;
                pos += normal * noise;
                vec4 mvPosition = modelViewMatrix * vec4(pos * uScale, 1.0);
                gl_PointSize = (4.0 + sizeOffset) * (300.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            void main() {
                vec2 xy = gl_PointCoord.xy - vec2(0.5);
                float ll = length(xy);
                if (ll > 0.5) discard;
                float alpha = (0.5 - ll) * 2.0;
                alpha = pow(alpha, 1.5); 
                gl_FragColor = vec4(vColor, alpha);
            }
        `;

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x050505);
            container.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createParticles();

            window.addEventListener('resize', onWindowResize);
            document.getElementById('fs-btn').addEventListener('click', toggleFullScreen);

            initMediaPipe(); // ÂÖ≥ÈîÆÂàùÂßãÂåñ
            animate();
        }

        function createParticles() {
            geometry = new THREE.BufferGeometry();
            
            positions = new Float32Array(CONFIG.particleCount * 3);
            initialPositions = new Float32Array(CONFIG.particleCount * 3);
            velocities = new Float32Array(CONFIG.particleCount * 3);
            colors = new Float32Array(CONFIG.particleCount * 3);
            const sizeOffsets = new Float32Array(CONFIG.particleCount);

            const color1 = new THREE.Color(0x00f0ff);
            const color2 = new THREE.Color(0x5500ff);

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const r = 40 + Math.random() * 40;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;

                initialPositions[i * 3] = x;
                initialPositions[i * 3 + 1] = y;
                initialPositions[i * 3 + 2] = z;

                const mixedColor = color1.clone().lerp(color2, Math.random());
                colors[i * 3] = mixedColor.r;
                colors[i * 3 + 1] = mixedColor.g;
                colors[i * 3 + 2] = mixedColor.b;

                sizeOffsets[i] = Math.random() * 2.0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('sizeOffset', new THREE.BufferAttribute(sizeOffsets, 1));

            material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uScale: { value: 1.0 }
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // --- GESTURE LOGIC & CAMERA ---
        async function initMediaPipe() {
            const videoElement = document.getElementById('input-video');
            const loadingText = document.getElementById('loading-text');
            
            // Ê£ÄÊü•ÂÖ®Â±ÄÂèòÈáè Hands ÊòØÂê¶Âä†ËΩΩÊàêÂäü
            if (typeof window.Hands === 'undefined') {
                loadingText.innerText = "Error: MediaPipe JS Failed to Load";
                console.error("MediaPipe Hands script not loaded");
                return;
            }

            loadingText.innerText = "LOADING AI MODEL (20MB)...";

            // Áõ¥Êé•‰ΩøÁî®ÂÖ®Â±Ä Hands ÂØπË±°
            const hands = new window.Hands({locateFile: (file) => {
                // ÊåáÂêë‰∏é JS ÁâàÊú¨‰∏ÄËá¥ÁöÑ CDN
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.6
            });

            hands.onResults(onHandsResults);

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: "user"
                    }
                });
                videoElement.srcObject = stream;
                
                videoElement.onloadeddata = () => {
                    document.getElementById('loader').style.opacity = 0;
                    setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
                    predictWebcam(hands, videoElement);
                };

            } catch (err) {
                console.error("Camera Error:", err);
                loadingText.innerText = "CAMERA ERROR: " + err.message;
            }
        }

        let lastVideoTime = -1;
        async function predictWebcam(hands, videoElement) {
            if (lastVideoTime !== videoElement.currentTime) {
                lastVideoTime = videoElement.currentTime;
                if (!videoElement.paused && !videoElement.ended) {
                    await hands.send({image: videoElement});
                }
            }
            requestAnimationFrame(() => predictWebcam(hands, videoElement));
        }

        function onHandsResults(results) {
            handLandmarks = results.multiHandLandmarks;
            processGestures();
        }

        function getDistance(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
        }

        function processGestures() {
            const statusEl = document.getElementById('system-status');
            const barEl = document.getElementById('gesture-bar');

            if (!handLandmarks || handLandmarks.length === 0) {
                gestureState = 'IDLE';
                statusEl.innerText = "IDLE (NO HANDS)";
                barEl.style.width = '0%';
                interaction.targetScale = 1.0;
                return;
            }

            if (handLandmarks.length === 2) {
                const h1 = handLandmarks[0][0]; 
                const h2 = handLandmarks[1][0];
                const dist = getDistance(h1, h2);
                interaction.targetScale = THREE.MathUtils.mapLinear(dist, 0.2, 0.8, 0.5, 2.0);
                interaction.targetScale = THREE.MathUtils.clamp(interaction.targetScale, 0.4, 2.5);
                statusEl.innerText = "SCALING";
            } else {
                interaction.targetScale = 1.0;
            }

            const hand = handLandmarks[0];
            const wrist = hand[0];
            const nX = (wrist.x - 0.5) * 2; 
            const nY = -(wrist.y - 0.5) * 2; 
            
            interaction.handPos.set(-nX * 50, nY * 30, 0); 
            interaction.handRotation = -nX * 0.5;

            const palm = hand[0];
            const fingertips = [8, 12, 16, 20];
            
            let avgDistToPalm = 0;
            fingertips.forEach(idx => {
                avgDistToPalm += getDistance(hand[idx], palm);
            });
            avgDistToPalm /= 4;

            const thumbTip = hand[4];
            const pinkyTip = hand[20];
            const spreadDist = getDistance(thumbTip, pinkyTip);
            const now = Date.now();

            if (avgDistToPalm < 0.15) {
                if (gestureState !== 'BLACK_HOLE') {
                    if (now - gestureTimer > 300) {
                        triggerBlackHole();
                        gestureTimer = now;
                    }
                }
                statusEl.innerText = "SINGULARITY DETECTED";
                barEl.style.width = '100%';
                barEl.style.backgroundColor = '#5500ff';
            } else if (spreadDist > 0.45) {
                if (gestureState !== 'SUPERNOVA') {
                    if (now - gestureTimer > 200) {
                        triggerSupernova();
                        gestureTimer = now;
                    }
                }
                statusEl.innerText = "ENERGY CRITICAL";
                barEl.style.width = '100%';
                barEl.style.backgroundColor = '#ffaa00';
            } else {
                if (gestureState !== 'IDLE' && now - gestureTimer > 1000) {
                     triggerIdle();
                }
            }
        }

        function triggerBlackHole() {
            if (gestureState === 'BLACK_HOLE') return;
            gestureState = 'BLACK_HOLE';
            gsap.to(bloomPass, { strength: 3.5, duration: 1.2, ease: "power2.in" });
            gsap.to(material.uniforms.uScale, { value: 0.4, duration: 1.2, ease: "expo.in" });
            fadeColors(CONFIG.colors.blackHoleRim, CONFIG.colors.blackHoleCore);
        }

        function triggerSupernova() {
            if (gestureState === 'SUPERNOVA') return;
            gestureState = 'SUPERNOVA';
            const tl = gsap.timeline();
            tl.to(material.uniforms.uScale, { value: 0.1, duration: 0.3, ease: "power2.in" });
            tl.to(bloomPass, { strength: 5.0, duration: 0.1 });
            tl.to(material.uniforms.uScale, { 
                value: 2.5, 
                duration: 0.8, 
                ease: "elastic.out(1, 0.5)",
                onStart: () => {
                    explodeParticles(); 
                    fadeColors(CONFIG.colors.novaRim, CONFIG.colors.novaCore);
                }
            });
            tl.to(bloomPass, { strength: 1.2, duration: 2.0 });
        }

        function triggerIdle() {
            gestureState = 'IDLE';
            gsap.to(bloomPass, { strength: 1.2, duration: 1.5 });
            gsap.to(material.uniforms.uScale, { value: 1.0, duration: 1.5 });
        }

        function fadeColors(cOuter, cInner) {
            const arr = geometry.attributes.color.array;
            for(let i=0; i<CONFIG.particleCount; i++) {
                const isCore = Math.random() > 0.5;
                const target = isCore ? cInner : cOuter;
                arr[i*3] = target.r;
                arr[i*3+1] = target.g;
                arr[i*3+2] = target.b;
            }
            geometry.attributes.color.needsUpdate = true;
        }

        function explodeParticles() {
            for(let i=0; i<CONFIG.particleCount; i++) {
                const ix = i*3, iy = i*3+1, iz = i*3+2;
                const vx = positions[ix], vy = positions[iy], vz = positions[iz];
                const len = Math.sqrt(vx*vx + vy*vy + vz*vz) + 0.001;
                const speed = 3.0 + Math.random() * 5.0; 
                velocities[ix] = (vx/len) * speed;
                velocities[iy] = (vy/len) * speed;
                velocities[iz] = (vz/len) * speed;
            }
        }

        function updatePhysics() {
            const positionsArr = geometry.attributes.position.array;
            
            interaction.currentScale = THREE.MathUtils.lerp(interaction.currentScale, interaction.targetScale, 0.1);
            interaction.smoothHandPos.lerp(interaction.handPos, 0.1);
            interaction.smoothHandRot = THREE.MathUtils.lerp(interaction.smoothHandRot, interaction.handRotation, 0.1);

            const cx = interaction.smoothHandPos.x;
            const cy = interaction.smoothHandPos.y;
            const cz = interaction.smoothHandPos.z;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const px = i * 3;
                let x = positionsArr[px], y = positionsArr[px+1], z = positionsArr[px+2];
                let vx = velocities[px], vy = velocities[px+1], vz = velocities[px+2];

                if (gestureState === 'BLACK_HOLE') {
                    const dx = cx - x, dy = cy - y, dz = cz - z;
                    const distSq = dx*dx + dy*dy + dz*dz + 1.0;
                    const dist = Math.sqrt(distSq);
                    const f = CONFIG.physics.G / distSq;
                    
                    vx += (dx / dist) * f * 0.1;
                    vy += (dy / dist) * f * 0.1;
                    vz += (dz / dist) * f * 0.1;

                    vx += -dz * 0.02; // Swirl
                    vz += dx * 0.02;

                    vx *= 0.92; vy *= 0.92; vz *= 0.92;

                } else if (gestureState === 'SUPERNOVA') {
                    vx *= 0.98; vy *= 0.98; vz *= 0.98;
                    vx += (Math.random()-0.5) * 0.2;
                    vy += (Math.random()-0.5) * 0.2;
                    vz += (Math.random()-0.5) * 0.2;

                } else {
                    const tx = initialPositions[px] * interaction.currentScale + cx;
                    const ty = initialPositions[px+1] * interaction.currentScale + cy;
                    const tz = initialPositions[px+2] * interaction.currentScale + cz;

                    vx += (tx - x) * CONFIG.physics.returnSpeed * 0.5;
                    vy += (ty - y) * CONFIG.physics.returnSpeed * 0.5;
                    vz += (tz - z) * CONFIG.physics.returnSpeed * 0.5;

                    vx *= 0.90; vy *= 0.90; vz *= 0.90;
                }

                x += vx; y += vy; z += vz;
                positionsArr[px] = x; positionsArr[px+1] = y; positionsArr[px+2] = z;
                velocities[px] = vx; velocities[px+1] = vy; velocities[px+2] = vz;
            }

            geometry.attributes.position.needsUpdate = true;
            particles.rotation.y = interaction.smoothHandRot;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            material.uniforms.uTime.value = time;
            updatePhysics();
            composer.render();

            if (Math.random() > 0.95) {
                document.getElementById('fps-counter').innerText = Math.round(1000 / (performance.now() - (animate.lastTime || performance.now())));
            }
            animate.lastTime = performance.now();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        }

        init();
    </script>
</body>
</html>
